# オブジェクト指向による制約突破 - FadingMovementSMB実装事例

## 概要
UnityのStateMachineBehaviourを使用した魚の逃避・帰還アニメーションシステムの実装において、技術的制約に対してオブジェクト指向設計により解決した事例。

**キーワード**: StateMachineBehaviour, Coroutine, シングルトンパターン, 責任の分離, ライフサイクル管理

---

## 1. 要件定義

### 実現したい動作
1. 魚が避難地点へ移動しながら半透明になる（AsylumSwim State）
2. 元の位置へ戻りながら不透明になる（ComeBackSwim State）
3. **移動時間は指定秒数で保証**（State滞在時間に依存しない）
4. Apply Root Motion = ONを維持（180度回転アニメーション用）
5. Animatorパラメータを追加したくない

### 技術要件
- 速度ベース移動: `speed = distance / time`
- State遷移のタイミングに関係なく移動完遂
- MaterialPropertyBlockで透明度制御（共有マテリアル変更回避）
- 親Transformを移動、子（Animator）はlocalPosition固定

---

## 2. 直面した技術的制約

### 制約1: StateMachineBehaviourはMonoBehaviourではない
```csharp
public class FadingMovementSMB : StateMachineBehaviour // MonoBehaviourではない
{
    // StartCoroutine()が使えない！
}
```

**問題**: Coroutineを直接実行できない

### 制約2: State遷移を外部から制御できない
- StateMachineBehaviourはAnimatorのStateライフサイクルに従属
- 遷移タイミングは`Has Exit Time`または`Conditions`でのみ制御可能
- 非同期処理の完了を待ってState遷移させる手段がない

### 制約3: Apply Root Motionによる位置上書き
- Apply Root Motion = ONの場合、AnimationがTransformを強制的に動かす
- スクリプトでの位置変更が毎フレーム上書きされる

### 要件の本質的矛盾
- **要件A**: State滞在時間に依存せず移動を保証
- **要件B**: Animatorパラメータを追加したくない
- **技術的事実**: 通常の方法ではAとBは両立不可能

---

## 3. 失敗したアプローチ

### 失敗1: OnStateUpdateでの直接移動
```csharp
public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
{
    UpdateMovement(); // 移動処理
    UpdateFade();     // 透明化処理
}
```

**問題**:
- State遷移時に`OnStateUpdate`が呼ばれなくなる
- `Has Exit Time`でState強制終了 → 移動が中断される
- `OnStateExit`で強制的に目標位置へ → **瞬間移動**

### 失敗2: 「Has Exit Timeで調整すればいい」
**問題**:
- Animation再生時間と移動完了時間が一致しない
- 移動途中でStateが切り替わる
- 結局`OnStateExit`でのワープが発生

### 失敗3: 「Animatorパラメータが必要」
**問題**:
- ユーザー要件を無視した妥協案
- 制約を理由に諦めている
- オブジェクト指向的発想の欠如

---

## 4. オブジェクト指向による解決

### 発想の転換
**従来の思考**: State遷移を制御して移動完了を待つ
**新しい思考**: State遷移に依存しない独立した実行機構を作る

**キーコンセプト**:
> 「制御できないなら依存しない」

### 設計方針

#### 責任の分離
- **StateMachineBehaviour**: 移動処理の「起動」のみ
- **MovementExecutor**: 移動処理の「実行」を担当

#### 独立したライフサイクル
- StateMachineBehaviourはStateに従属
- MovementExecutorは独立したGameObjectとして存在
- `DontDestroyOnLoad`でシーン遷移でも破棄されない

#### シングルトンパターン
- 複数StateでExecutorを共有
- 無駄なGameObject生成を防ぐ
- 実行中のCoroutineを確実に管理

---

## 5. 実装

### MovementExecutor (シングルトンMonoBehaviour)

```csharp
/// <summary>
/// 非同期移動処理を実行するシングルトンMonoBehaviour
/// State遷移に依存せず、移動完了まで処理を継続する
/// </summary>
class MovementExecutor : MonoBehaviour
{
    static MovementExecutor instance;
    Coroutine currentCoroutine;

    /// <summary>
    /// シングルトンインスタンス取得
    /// 初回呼び出し時に自動生成、DontDestroyOnLoadで永続化
    /// </summary>
    public static MovementExecutor GetInstance()
    {
        if (instance == null)
        {
            GameObject obj = new GameObject("FadingMovementExecutor");
            instance = obj.AddComponent<MovementExecutor>();
            DontDestroyOnLoad(obj); // シーン遷移でも破棄されない
        }
        return instance;
    }

    /// <summary>
    /// 移動処理を開始（既存のCoroutineは停止）
    /// </summary>
    public void StartMovement(Transform target, Transform destination,
        Renderer renderer, MaterialPropertyBlock propertyBlock,
        float moveSpeed, float fadeSpeed, float targetAlpha, int opacityID)
    {
        // 既存のCoroutineを停止（State遷移時の重複実行を防ぐ）
        if (currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
        }

        currentCoroutine = StartCoroutine(
            ExecuteMovement(target, destination, renderer, propertyBlock,
                          moveSpeed, fadeSpeed, targetAlpha, opacityID)
        );
    }

    /// <summary>
    /// 移動と透明化を並行実行（完了まで継続）
    /// </summary>
    IEnumerator ExecuteMovement(Transform target, Transform destination,
        Renderer renderer, MaterialPropertyBlock propertyBlock,
        float moveSpeed, float fadeSpeed, float targetAlpha, int opacityID)
    {
        Material targetMaterial = renderer.material;
        bool isCompleted = false;

        while (!isCompleted)
        {
            // 移動処理
            Vector3 currentPosition = target.position;
            Vector3 targetPosition = destination.position;
            Vector3 direction = (targetPosition - currentPosition).normalized;
            float stepDistance = moveSpeed * Time.deltaTime;

            if (Vector3.Distance(currentPosition, targetPosition) <= stepDistance)
            {
                target.position = targetPosition;
            }
            else
            {
                target.position = currentPosition + direction * stepDistance;
            }

            // 透明度処理
            renderer.GetPropertyBlock(propertyBlock);
            float currentAlpha = propertyBlock.HasFloat(opacityID)
                ? propertyBlock.GetFloat(opacityID)
                : targetMaterial.GetFloat(opacityID);

            float alphaStep = fadeSpeed * Time.deltaTime;
            float alphaDifference = Mathf.Abs(targetAlpha - currentAlpha);

            if (alphaDifference <= alphaStep)
            {
                propertyBlock.SetFloat(opacityID, targetAlpha);
            }
            else
            {
                float newAlpha = currentAlpha + Mathf.Sign(targetAlpha - currentAlpha) * alphaStep;
                propertyBlock.SetFloat(opacityID, newAlpha);
            }

            renderer.SetPropertyBlock(propertyBlock);

            // 完了判定
            bool positionReached = Vector3.Distance(target.position, destination.position) < 0.001f;
            bool alphaReached = Mathf.Abs(propertyBlock.GetFloat(opacityID) - targetAlpha) < 0.001f;

            if (positionReached && alphaReached)
            {
                isCompleted = true;
                Debug.Log($"FadingMovementSMB: 到達完了 | 位置: {target.position}");
                break; // 完了したら即座にループ終了
            }

            yield return null;
        }

        currentCoroutine = null;
    }
}
```

### StateMachineBehaviour側の実装

```csharp
public class FadingMovementSMB : StateMachineBehaviour
{
    [Header("移動設定")]
    [SerializeField] string targetPointName;
    [SerializeField] float moveDuration = 2f;

    [Header("透明度設定")]
    [SerializeField] float targetAlpha = 0.3f;

    Transform targetPoint;
    Transform targetTransform;
    Transform animatorTransform;
    Renderer targetRenderer;
    MaterialPropertyBlock propertyBlock;

    Vector3 startPosition;
    float startAlpha;
    float moveSpeed;
    float fadeSpeed;

    static readonly int OpacityAddID = Shader.PropertyToID("_OpacityAdd");

    /// <summary>
    /// State進入時: MovementExecutorで非同期移動を開始
    /// </summary>
    public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        InitializeComponents(animator);
        FindTargetPoint();
        InitializeStartValues();

        // シングルトンExecutorで非同期移動を開始
        // この後Stateが遷移してもCoroutineは継続実行される
        MovementExecutor executor = MovementExecutor.GetInstance();
        executor.StartMovement(targetTransform, targetPoint, targetRenderer,
                              propertyBlock, moveSpeed, fadeSpeed, targetAlpha, OpacityAddID);
    }

    /// <summary>
    /// Apply Root Motionによる子の移動を毎フレーム打ち消す
    /// </summary>
    public override void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        if (targetTransform == null || animatorTransform == null) return;

        // Apply Root Motionによる子の移動を打ち消す
        animatorTransform.localPosition = Vector3.zero;
    }

    void InitializeComponents(Animator animator)
    {
        animatorTransform = animator.transform;
        targetTransform = animatorTransform.parent; // 親を移動対象にする

        if (targetRenderer == null)
        {
            targetRenderer = animator.GetComponentInChildren<Renderer>();
        }

        if (propertyBlock == null)
        {
            propertyBlock = new MaterialPropertyBlock();
        }
    }

    void FindTargetPoint()
    {
        if (targetPoint != null) return; // キャッシュ済みなら再検索しない

        GameObject targetObj = GameObject.Find(targetPointName);
        if (targetObj != null)
        {
            targetPoint = targetObj.transform;
        }
    }

    void InitializeStartValues()
    {
        if (targetPoint == null) return;

        startPosition = targetTransform.position;

        // 速度 = 距離 / 時間
        float distance = Vector3.Distance(startPosition, targetPoint.position);
        moveSpeed = distance / moveDuration;

        targetRenderer.GetPropertyBlock(propertyBlock);
        startAlpha = propertyBlock.HasFloat(OpacityAddID)
            ? propertyBlock.GetFloat(OpacityAddID)
            : 1f;

        float alphaDifference = Mathf.Abs(targetAlpha - startAlpha);
        fadeSpeed = alphaDifference / moveDuration;
    }
}
```

---

## 6. 実装のポイント

### ポイント1: シングルトンの正当性
**なぜシングルトンが適切か**:
- StateMachineBehaviourはインスタンス生成を制御できない
- 複数StateでExecutorを共有する必要がある
- リソース効率（無駄なGameObject生成を防ぐ）
- 実行中のCoroutineを確実に管理・停止できる

**シングルトンがアンチパターンとされる理由**:
- グローバルステートによる暗黙的依存
- テスタビリティの低下
- 密結合の誘発

**今回は適材適所**: ライフサイクル管理が特殊で他の手段がない状況

### ポイント2: DontDestroyOnLoad
```csharp
DontDestroyOnLoad(obj);
```
- シーン遷移でもGameObjectが破棄されない
- MovementExecutorが永続的に存在
- State遷移どころかシーン遷移でも処理が継続される

### ポイント3: 既存Coroutineの停止
```csharp
if (currentCoroutine != null)
{
    StopCoroutine(currentCoroutine);
}
```
- State遷移時に新しい移動処理が開始される
- 前の処理を停止してから新しい処理を開始
- 重複実行を防ぐ

### ポイント4: 完了時の即座break
```csharp
if (positionReached && alphaReached)
{
    isCompleted = true;
    Debug.Log($"FadingMovementSMB: 到達完了 | 位置: {target.position}");
    break; // 完了したら即座にループ終了
}
```
- `yield return null`の後にループ終了すると、次フレームまで待たされる
- その間に新しいStateに遷移すると`currentCoroutine`がまだnullでない
- `break`で即座に終了し、`currentCoroutine = null`を実行

### ポイント5: Apply Root Motionへの対応
```csharp
public override void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
{
    animatorTransform.localPosition = Vector3.zero;
}
```
- 親Transformを移動、子（Animator）は固定
- `OnStateMove`はAnimatorがRoot Motionを適用した後に呼ばれる
- 子のlocalPositionを毎フレーム(0,0,0)にリセット

---

## 7. 動作フロー

### 初回AsylumSwim State実行時
```
1. OnStateEnter呼び出し
   ↓
2. MovementExecutor.GetInstance()
   → 初回のみGameObject生成 + DontDestroyOnLoad
   ↓
3. executor.StartMovement()
   → Coroutine開始（避難地点への移動+半透明化）
   ↓
4. State遷移（Has Exit Timeで自動遷移）
   ↓
5. Coroutineは継続実行中（State遷移に影響されない）
   ↓
6. 移動完了 → Coroutine終了
```

### ComeBackSwim State実行時
```
1. OnStateEnter呼び出し
   ↓
2. MovementExecutor.GetInstance()
   → 既にインスタンス存在（再利用）
   ↓
3. executor.StartMovement()
   → 前のCoroutineを停止
   → 新しいCoroutine開始（元の位置への移動+不透明化）
   ↓
4. State遷移（Has Exit Timeで自動遷移）
   ↓
5. Coroutineは継続実行中
   ↓
6. 移動完了 → Coroutine終了
```

### 重要な点
- **State遷移のタイミングと移動完了のタイミングは無関係**
- Stateが早く遷移しても、Coroutineは最後まで実行される
- 瞬間移動（ワープ）が発生しない

---

## 8. 成果

### 実現できたこと
- ✅ State滞在時間に完全非依存の移動保証
- ✅ Animatorパラメータ追加なし
- ✅ 瞬間移動（ワープ）の解消
- ✅ Apply Root Motion = ONを維持
- ✅ 複数Stateでの再利用可能な設計
- ✅ シーン遷移でも処理継続（DontDestroyOnLoad）

### パフォーマンス最適化
- GameObject.Findの結果をキャッシュ
- Shader.PropertyToIDを`static readonly`で事前計算
- MaterialPropertyBlockで共有マテリアル変更を回避
- シングルトンで無駄なGameObject生成を防止

---

## 9. 学ぶべき教訓

### 教訓1: 制約は設計の機会
> 「この制約があるから無理」ではなく
> 「制約を持つオブジェクトに依存しない別のオブジェクトを作る」

### 教訓2: オブジェクト指向の本質
**責任の分離**:
- 制約のあるオブジェクト: 起動のみ
- 独立したオブジェクト: 実行を担当

**ライフサイクルの独立**:
- 制約に縛られない独自の生存期間
- 依存元が消えても処理は継続

**カプセル化**:
- 複雑な処理を独立したオブジェクト内部に閉じ込める
- 外部からは単純なインターフェースで操作

### 教訓3: パターンは適材適所
シングルトンはアンチパターンとされることもあるが:
- ライフサイクル管理が特殊
- リソース効率が重要
- 状態の一貫性が必要
- 他の手段がない

このような状況では正当な選択。

### 教訓4: 「制御できないなら依存しない」
これがオブジェクト指向による不可能の可能化。

- State遷移を制御できない → State遷移に依存しない設計
- MonoBehaviourでない → MonoBehaviourを別に作る
- ライフサイクルが制約される → 独立したライフサイクルを作る

### 教訓5: 質問による解の誘導
「できない」で終わらず、自問自答:
- 「内部で完結できないか？」
- 「再利用できないか？」
- 「非同期で継続できないか？」
- 「別のオブジェクトに委譲できないか？」

---

## 10. 比較: 従来手法 vs オブジェクト指向手法

### 従来手法（失敗）
```
StateMachineBehaviour
    ├─ OnStateUpdate() で移動処理
    ├─ State遷移で処理中断
    └─ OnStateExit() で強制ワープ

問題:
- State滞在時間に依存
- 瞬間移動が発生
- 要件を満たせない
```

### オブジェクト指向手法（成功）
```
StateMachineBehaviour (起動)
    └─ MovementExecutor (実行)
            ├─ 独立したGameObject
            ├─ DontDestroyOnLoad
            ├─ シングルトン
            └─ Coroutineで完了まで実行

利点:
- State遷移に非依存
- 瞬間移動なし
- 要件を完全達成
```

---

## 11. まとめ

### 技術的成果
FadingMovementSMBの実装により、Unity Animatorの制約を突破し、State滞在時間に依存しない移動保証システムを実現。

### 設計思想の成果
**オブジェクト指向による制約突破**:
1. 制約の正確な理解
2. 発想の転換（制御 → 非依存）
3. 責任の分離
4. 独立したライフサイクル
5. 適切なパターン適用

### 普遍的な価値
この事例は、UnityやStateMachineBehaviourに限らず、あらゆる技術的制約に対する解決アプローチとして応用可能:

> **「制約を持つシステムに依存しない独立したシステムを作る」**

これがオブジェクト指向設計の真髄であり、不可能を可能にする思考法である。

---

## 付録: 完全なソースコード

完全なソースコードは以下に配置:
- `C:\Users\Simna\KWS2 DynamicWaterAsset\Assets\Scripts\FadingMovementSMB.cs`

使用例:
1. Animator ControllerのStateにFadingMovementSMBをアタッチ
2. Inspector で `targetPointName` と `moveDuration`, `targetAlpha` を設定
3. 親GameObjectに魚モデルをアタッチ（Apply Root Motion = ON）
4. 実行すると自動的にMovementExecutorが生成され、移動処理が開始される
