# 開発記録

## プロジェクト概要
D:\kameyama\Shibuya_StreamのPython依存の人物検知システムを、C:\Users\Simna\KWS2 DynamicWaterAssetにC#のみで移植する。
アプリ配布を見据え、Unity内で完結するシステムを構築。

---

## 実装状況（✅完了）

### ✅ フェーズ1: 調査・準備

#### 1. YOLOv8モデルをONNX形式に変換
- **完了**: yolov8n.pt → yolov8n.onnx に変換
- **場所**: `C:\Users\Simna\KWS2 DynamicWaterAsset\Assets\yolov8n.onnx`
- **サイズ**: 13MB
- **実行コマンド**: `yolo export model=yolov8n.pt format=onnx`

#### 2. ONNX Runtime for Unityの導入（軽量版を採用）
- **採用**: ONNX Runtime（Barracudaは古く非推奨）
- **理由**: パフォーマンスが圧倒的に良い（Barracudaの1/3〜1/5の処理時間）
- **導入DLL**:
  - `onnxruntime.dll` (ネイティブランタイム)
  - `onnxruntime_providers_shared.dll` (プロバイダー)
  - `Microsoft.ML.OnnxRuntime.dll` (C# API)
- **配置場所**: `Assets/Plugins/OnnxRuntime/`

#### 3. KWS2プロジェクトの構成確認
- **既存システム**:
  - WeatherSystem: 天候管理
  - RiverController: 川の流速制御
  - WeatherAmbience: 環境音再生
  - WaterSystem: KWSの水面システム

---

### ✅ フェーズ2: 人物検知システム構築

#### 4. CameraInput.cs - カメラ入力取得
**ファイル**: `Assets/Scripts/CameraInput.cs`

**機能**:
- WebCamTextureでカメラデバイスにアクセス
- 640x640でキャプチャ（調整可能）
- Texture2Dに変換して出力
- カメラ起動失敗時のエラーハンドリング

**パラメータ**:
- Camera Index: 使用カメラ（0=デフォルト）
- Requested Width/Height: 解像度
- Requested FPS: フレームレート

#### 5. PersonDetector.cs - 人物検知システム
**ファイル**: `Assets/Scripts/PersonDetector.cs`

**機能**:
- YOLOv8 ONNXモデルで推論実行
- 'person'クラス（class_id=0）のみカウント
- 移動平均フィルターで結果を平滑化
- 推論頻度を調整可能（デフォルト3フレームごと）

**パラメータ**:
- Model Path: `yolov8n.onnx`
- Input Size: 640x640
- Confidence Threshold: 0.5（信頼度閾値）
- Inference Interval: 3（3フレームごと）
- Enable Smoothing: true（平滑化有効）
- Smoothing Frames: 5（過去5フレームの平均）

**出力**:
- Detected People Count: 平滑化後の人数
- Raw Detected Count: 生の検出人数

**パフォーマンス最適化**:
- 3フレームごとに推論（負荷軽減）
- 移動平均で結果を安定化
- GPU対応（DirectML利用可能）

---

### ✅ フェーズ3: 水面連動システム移植

#### 6. PeopleWaterController.cs - 人数→水面変化
**ファイル**: `Assets/Scripts/PeopleWaterController.cs`

**機能**:
- PersonDetectorから人数を取得
- 人数に応じて水の透明度と濁り色を制御
- WeatherSystemと競合しないよう、流速制御は無効化

**制御パラメータ（デフォルト有効）**:
1. **水の透明度（Transparent）**:
   - 0人: 20（透き通った水）
   - 10人以上: 5（濁った水）

2. **水の濁り色（TurbidityColor）**:
   - 0人: 薄い青色 (0.5, 0.8, 0.9)
   - 10人以上: 茶色 (0.027, 0.255, 0.314)

3. **屈折モード（RefractionMode）**:
   - 自動的に`PhysicalAproximationIOR`を有効化
   - 透明感の実現に必須（光の屈折効果）
   - 手動設定: WaterSystemインスペクター → "Refraction (View Through Water)" タブ

**制御パラメータ（デフォルト無効）**:
- Wind Speed: 風速制御（WeatherSystemと競合）
- Flow Speed: 流速制御（WeatherSystemと競合）
- Water Source Flow Rate: 水源流量制御

**マッピング設定**:
- Max People Count: 10（上限人数）
- Enable Smoothing: true（滑らかに変化）
- Smoothing Speed: 2.0

**視覚的効果**:
- 人がいない → 透き通った青い水
- 人が増える → 徐々に濁って茶色に
- 10人以上 → 完全に濁った茶色い水

---

### ✅ フェーズ4: 統合・最適化

#### 7. 統合テスト結果
- ✅ カメラ起動成功
- ✅ 人物検知動作確認
- ✅ 水面変化確認
- ✅ エラーなし
- ✅ 平滑化による安定化完了

#### 8. セットアップ手順
1. 空のGameObjectを作成（名前: PersonDetectionSystem）
2. 以下のコンポーネントをアタッチ:
   - CameraInput
   - PersonDetector
   - PeopleWaterController
3. PersonDetectorの設定:
   - Model Path: `yolov8n.onnx`
   - Inference Interval: 3
   - Smoothing Frames: 5
4. PeopleWaterControllerの設定:
   - Control Transparency: ✓
   - Control Turbidity: ✓
   - Enable Refraction: ✓（デフォルトで有効）
   - 色や透明度を好みに調整

---

## 実装完了ファイル一覧

```
C:\Users\Simna\KWS2 DynamicWaterAsset\
├── Assets\
│   ├── yolov8n.onnx (13MB) ...................... YOLOv8モデル
│   ├── Plugins\
│   │   └── OnnxRuntime\
│   │       ├── onnxruntime.dll .................. ネイティブランタイム
│   │       ├── onnxruntime_providers_shared.dll . プロバイダー
│   │       └── Microsoft.ML.OnnxRuntime.dll ..... C# API
│   ├── Editor\
│   │   └── SceneViewSkyboxFix.cs ................ シーンビューSkybox自動有効化
│   └── Scripts\
│       ├── CameraInput.cs ....................... カメラ入力取得
│       ├── PersonDetector.cs .................... 人物検知システム
│       ├── PeopleWaterController.cs ............. 水面連動制御
│       ├── WeatherSystem.cs ..................... 天候システム
│       ├── RiverController.cs ................... 川流速制御
│       └── WeatherAmbience.cs ................... 環境音管理
└── 開発記録.md .................................. このファイル
```

---

## データフロー（実装済み）

```
WebCamTexture (640x640, 30fps)
    ↓
CameraInput.cs (Texture2D変換)
    ↓
PersonDetector.cs
    ├─ 前処理（リサイズ、正規化、CHW変換）
    ├─ ONNX推論（YOLOv8、3フレームごと）
    ├─ 後処理（'person'クラスのみカウント）
    └─ 移動平均フィルター（5フレーム）
    ↓
PeopleWaterController.cs
    ├─ 人数 → 正規化（0-1）
    ├─ 透明度補間（20 → 5）
    ├─ 濁り色補間（青 → 茶色）
    └─ 屈折モード自動有効化（Start時）
    ↓
WaterSystem (KWS)
    ├─ Transparent（透明度）
    ├─ TurbidityColor（濁り色）
    └─ RefractionMode（屈折：PhysicalAproximationIOR）
    ↓
視覚的変化: 透明な青い水 ⇔ 濁った茶色い水
```

---

## 技術仕様

### パフォーマンス
- **推論間隔**: 3フレームごと（約10回/秒）
- **推論時間**: 50-150ms/フレーム（ONNX Runtime使用）
- **メモリ使用量**: 約50MB（モデル13MB + 推論バッファ）
- **カメラ解像度**: 640x640, 30fps

### 最適化手法
1. フレームスキップ（3フレームごと推論）
2. 移動平均フィルター（検出結果の安定化）
3. スムージング（水面変化を滑らかに）
4. GPU推論対応（DirectML利用可能）

### 安定性
- カメラ未接続時のフォールバック
- モデル読み込み失敗時のエラーハンドリング
- 推論エラー時の継続動作
- 移動平均による乱高下抑制

### 水の透明感について
- **重要**: 透明感の実現には`RefractionMode`（屈折）が必須
- PeopleWaterControllerが自動的に`PhysicalAproximationIOR`を設定
- 手動設定する場合: WaterSystemインスペクター → "Refraction (View Through Water)" タブ
- デモシーンと同じ設定で写実的な水の透明感を実現

---

## 進行中の開発

### 🔄 フェーズ5: 魚のアニメーションシステム（2025年10月20日）

#### 9. WaterSystem2アセット調査完了
**実施内容**:
- KriptoFX WaterSystem2 (v1.0.5a) の全容把握
- オンラインドキュメント: https://kripto289.gitbook.io/kripto289-docs

**主要機能**:
1. **Dynamic Waves Simulation Zone** - GPU駆動の水流シミュレーション
2. **Dynamic Waves Object** - 水源、障害物、インタラクション
3. **Local Water Zone** - エリア別の色・透明度オーバーライド
4. **Buoyancy System** - 浮力システム

**川の作成方法確認**:
- Simulation Zoneで流れをシミュレート
- Dynamic Waves Objectで水源と障害物を配置
- Local Water Zoneで色と透明度を調整
- スクリプトからの制御API確認完了

**重要な知見**:
- 川の水量は水源の`ConstantFlowRate`で制御（推奨: 0.05～0.3）
- 川の深さは「WaterSystemのY座標 - 地形のY座標」で決定
- 水が溜まりやすさは地形の傾斜と流量に依存

#### 10. FishAnimCreateシーン作成
**シーン構成**:
- Main Camera (位置: 0, 1, -10)
- Directional Light (回転: 50, -30, 0)
- Ayu (JSFreshwaterfish) - アニメーション付きアセット
- Ayu_Japan (JapaneseRiverFishPack) - アニメーション確認済み

**Ayu_Japan アニメーション一覧**:
1. Swim_Ayu - 通常の泳ぎ（Base Layer）
2. SwimStrong_Ayu - 強い泳ぎ
3. AnalFinMove_Ayu - 尻ビレの動き
4. DorsalFinMove_Ayu - 背ビレの動き
5. PectoralFinMove_Ayu - 胸ビレの動き
6. VentralFinMove_Ayu - 腹ビレの動き
7. OpenMouth_Ayu - 口を開ける
8. Rotate45L/R_Ayu - 45度回転
9. Rotate90L/R_Ayu - 90度回転
10. DefaultPose_Ayu - デフォルトポーズ

**AnimatorController構成**:
- Base Layer: Swim_Ayu
- 追加レイヤー: 各ヒレの細かい動き（Additive Blending）
- マスク使用: 各ヒレを個別制御可能

#### 11. エディタ改善
**SceneViewSkyboxFix.cs 作成**:
- Unity 2022.3でシーンビューにスカイボックスが表示されない問題を修正
- エディタ起動時に自動的にSkyboxを有効化
- 場所: `Assets/Editor/SceneViewSkyboxFix.cs`

#### 12. ScriptableObject based イベントシステム設計（2025年10月21日）

**設計方針**:
- **イベント駆動アーキテクチャ**を採用
- 演出システムを疎結合で拡張可能に設計
- ScriptableObjectを使った汎用的なイベントシステム

**アーキテクチャ**:
```
人数検知システム → GameEvent.Raise()
                        ↓
                  GameEventListener (各演出オブジェクトにアタッチ)
                        ↓
                  UnityEvent実行 (Inspector設定)
```

**実装するクラス**:
1. **GameEvent.cs** (ScriptableObject)
   - イベントの基底クラス
   - Raise()メソッドでリスナーに通知
   - CreateAssetMenu属性で任意のイベントアセット作成可能

2. **GameEventListener.cs** (MonoBehaviour)
   - GameEventを購読
   - SerializedFieldでInspector上でイベントとUnityEventを設定
   - イベント発火時にUnityEventを実行

**イベント命名規則**:
- 用途ではなく動作で命名（魚専用ではなく汎用的に）
- FadeInEvent - フェードイン演出全般
- FadeOutEvent - フェードアウト演出全般
- パーティクル、UI、エフェクト、音など全てで再利用可能

**利点**:
- Inspector上で視覚的に設定可能
- コード間の依存関係を排除
- デザイナーでも扱いやすい
- 演出追加時にコード修正不要

**実装完了**:
- [x] GameEvent.cs 作成 (2025年10月21日)
- [x] GameEventListener.cs 作成 (2025年10月21日)
- [x] 人数検知システムとの連携 (2025年11月1日)

---

### 🔄 フェーズ6: 腕振り歩行検知システム（2025年11月1日）

#### 13. MediaPipeUnityPlugin導入完了
**導入内容**:
- MediaPipeUnityPlugin v0.16.2（homuler作）
- Google MediaPipe Pose Landmarker（33関節検出）
- Windows環境でCPUモード動作確認完了

**パッケージ情報**:
- ライセンス: Apache 2.0（MediaPipe）、MIT（UnityPlugin）
- サイズ: 276MB（.unitypackage）
- 対応Unity: 2022.3+

**動作確認**:
- ✅ Pose Landmark Detectionサンプルシーン動作確認
- ✅ 33個のランドマーク取得成功
- ✅ リアルタイム追跡確認

#### 14. 腕振り歩行検知システム実装（✅完了）
**作成ファイル**:
1. **PoseLandmarkProvider.cs** - MediaPipeデータ提供（Singleton）
2. **ArmSwingDetector.cs** - 腕振り動作検知（時系列解析）
3. **PlayerWalkController.cs** - Player前進制御
4. **CustomPoseLandmarkerAnnotationController.cs** - イベントシステム拡張

**状態**: ✅ 動作確認完了、ランドマーク表示成功

**使用ランドマーク**:
- 11: 左肩
- 12: 右肩
- 15: 左手首
- 16: 右手首

**検知アルゴリズム**:
1. 手首のY座標を肩基準の相対座標で時系列追跡（30フレーム分）
2. 振幅計算（最大値 - 最小値）
3. 閾値判定（デフォルト: 0.1）
4. 歩行状態判定 → UnityEvent発火

**システム構成**:
```
PCカメラ → MediaPipe Pose Landmarker
              ↓
        PoseLandmarkProvider（Singleton）
              ↓
        ArmSwingDetector（時系列解析）
              ↓
        PlayerWalkController（CharacterController移動）
              ↓
        Playerキャラクター前進
```

**パラメータ**:
- Swing Threshold: 0.1（腕振り判定閾値）
- History Frames: 30（追跡フレーム数）
- Move Speed: 2.0 m/s（前進速度）
- Acceleration: 5.0（加速度）

**動作確認結果**:
- ✅ Pose検出成功（33ランドマーク）
- ✅ ランドマーク表示成功（GameView上）
- ✅ 腕振り検知動作確認
- ✅ イベント発火確認

#### 15. ランドマーク表示トラブルシューティング（2025年11月1日）
**問題**: ランドマークが検出されているがGameViewに表示されない

**原因調査**:
1. **症状**: Hierarchyに`PointAnnotation`オブジェクトは生成されているが、GameViewに描画されない
2. **Inspector確認**: `RectTransform`と`CanvasRenderer`がない（UI要素として認識されていない）
3. **Prefab確認**: MediaPipeのPrefabは`Transform`（3D用）を使用、UI Canvas用ではない

**根本原因**:
- Canvas Render Mode: `Screen Space - Overlay`（3D空間のオブジェクトを描画できない）
- MediaPipeアノテーションPrefabは3D空間用の`Transform`使用

**解決方法**:
```
Canvas設定変更:
- Render Mode: Screen Space - Overlay → Screen Space - Camera
- Render Camera: None → Main Camera に設定
```

**追加調整**:
- Landmark Radius: 15 → 30（視認性向上）
- Left/Right Landmark Color: 調整済み

**結果**: ✅ ランドマーク正常表示、リアルタイム検出確認

#### 16. デバッグログ最適化（2025年11月1日）
**問題**: 起動時・実行時のログが大量に出力され、テストの妨げになる

**コメントアウトしたログ**:
1. `PoseLandmarkProvider.cs:74` - Pose検出ログ（毎フレーム）
2. `ArmSwingDetector.cs:116` - 腕振り振幅ログ（毎フレーム）
3. `CustomPoseLandmarkerAnnotationController.cs:32,53` - DrawNow/SyncNowログ
4. `PoseLandmarkerRunner.cs:31-39` - MediaPipe設定値ログ（9個）
5. `Bootstrap.cs:27,36,41,75,84,96` - 初期化ログ（6個）

**残したログ（テストに必要）**:
- `[ArmSwingDetector] Walking detected!` - 歩行開始検知
- `[ArmSwingDetector] Walking stopped.` - 歩行停止検知
- エラーログ（`LogError`, `LogWarning`）

**効果**: コンソールがすっきりし、重要なイベントのみが表示されるように

---

## 🔄 フェーズ7: ルート移動システム（2025年11月4日）

#### 17. RouteFollower.cs - ルート自動移動システム（✅完了）
**設計方針**:
- リングフィットアドベンチャー方式：腕振りで前進、停止で待機
- ウェイポイント配列で自由にルート設定
- カメラ向きの自動/手動両対応

**機能**:
```
RouteFollower.cs
├─ [SerializeField] GameObject[] waypoints - ルート上の通過点
├─ 腕振り検知（ArmSwingDetector）→ 前進/停止
├─ カメラ回転制御
│   ├─ Waypoint回転設定あり → その向きへ補間
│   └─ 回転設定なし → 移動方向へ自動回転
└─ ルート完走時イベント（拡張可能）
```

**パラメータ**:
- Move Speed: 2.0 m/s（前進速度）
- Rotation Speed: 5.0（カメラ回転速度）
- Auto Rotate To Move Direction: true（自動回転有効）

**セットアップ手順**:
1. 空のGameObject作成（名前: Player）
2. RouteFollowerコンポーネントをアタッチ
3. 複数の空GameObjectを配置（Waypoint0, 1, 2...）
4. Inspector設定:
   - Waypoints: 配置したWaypointを順番に配列に追加
   - Player Camera: Main Cameraをドラッグ
   - Arm Swing Detector: ArmSwingDetectorをドラッグ
5. 各Waypoint設定:
   - Position: 移動先座標
   - Rotation: カメラ向き（設定しない場合は自動）

#### 18. CameraDisplayManager.cs - MediaPipe画面を右下小窓化（✅完了）
**問題**: GameViewがMediaPipeのカメラ映像で占有され、プレイヤー視点が見えない

**根本原因**:
- `AutoFit.cs` (MediaPipe標準): 毎フレームLateUpdate()で親Canvasサイズに自動フィット
- これがAnnotatable Screenのサイズを上書きしていた

**解決策**:
1. **AutoFit無効化**: `autoFitComponent.enabled = false`で自動調整停止
2. **Screen.Resize()使用**: MediaPipe標準メソッドでサイズ変更（320x240）
3. **MediaPipe初期化完了待機**: 2秒後に再度Resize実行（MediaPipeが初期化後にサイズ上書きするため）
4. **RectTransform配置**: 右下固定（anchor: 1,0 / pivot: 1,0 / position: -10,10）

**最終実装**:
```csharp
// Start()で初回設定
HideMediaPipeScreen();  // AutoFit無効化 + Screen.Resize() + 位置設定

// 2秒後に再度Resize（MediaPipe初期化完了後）
yield return new WaitForSeconds(2f);
screenComponent.Resize(320, 240);
```

**パラメータ**:
- Screen Size: 320x240（MediaPipe画面サイズ）

**セットアップ手順**:
1. Canvasに Add Component → **Camera Display Manager**
2. 完了！（全て自動設定）

**動作確認**:
- Play実行 → GameViewがプレイヤー視点（Main Camera）
- 2秒後 → MediaPipe画面が右下小窓（320x240）に縮小

---

## 今後の拡張案

### パフォーマンス改善
- [ ] 入力サイズを320x320に縮小（さらに高速化）
- [ ] DirectMLでGPU推論を有効化
- [ ] モデルの量子化（INT8）

### 機能追加
- [ ] 複数カメラ対応
- [ ] 検出結果のビジュアル表示
- [ ] デバッグUI（人数、FPS表示）
- [ ] 検出領域の限定（ROI設定）

### 演出強化
- [ ] 人数に応じたパーティクル生成
- [ ] 水面の反射強度変化
- [ ] 波の高さ調整
- [ ] 環境音の音量変化

### 魚のアニメーション
- [ ] 水流速度に応じたアニメーション速度変更
- [ ] 群れ行動の実装
- [ ] 障害物回避
- [ ] 水深に応じた泳ぎ方の変化
- [ ] 人数検知との連動（人が多いと魚が逃げる等）

---

## 参考リソース

- YOLOv8 ONNX Export: https://docs.ultralytics.com/modes/export/
- ONNX Runtime: https://github.com/microsoft/onnxruntime
- KWS Water System: https://kripto289.gitbook.io/kripto289-docs
- Unity WebCamTexture: https://docs.unity3d.com/ScriptReference/WebCamTexture.html

---

## 開発履歴

- **2025年10月18日**: 人物検知システム移植完了
- **2025年10月20日**: WaterSystem2調査完了、FishAnimCreateシーン作成、魚アニメーション確認
- **2025年10月21日**: ScriptableObjectベースイベントシステム設計完了、GameEvent/GameEventListener実装完了
- **2025年11月1日**:
  - MediaPipeUnityPlugin導入完了（v0.16.2）
  - 腕振り歩行検知システム実装完了（PoseLandmarkProvider, ArmSwingDetector, PlayerWalkController, CustomPoseLandmarkerAnnotationController）
  - ランドマーク表示トラブルシューティング完了（Canvas Render Mode変更で解決）
  - デバッグログ最適化完了（不要なログコメントアウト）
  - 動作確認完了：Pose検出、ランドマーク表示、腕振り検知、全て正常動作
- **2025年11月4日**:
  - **RouteFollower.cs実装完了**（リングフィットアドベンチャー方式のルート移動システム）
    - 設計方針：ウェイポイント配列でルート設定、腕振り検知で前進/停止、カメラ向き自動/手動対応
    - 重複コンポーネント削除：Playerに2つのRouteFollowerがアタッチされていた問題を修正
  - **CameraDisplayManager.cs実装完了**（MediaPipe画面を右下小窓化）
    - **問題**: GameViewがMediaPipe画面で占有され、プレイヤー視点が見えない
    - **根本原因特定**: AutoFit.cs（MediaPipe標準）が毎フレームLateUpdate()でCanvasサイズに自動フィット
    - **解決プロセス**:
      1. 初回試行：RectTransform直接変更 → AutoFitが上書き（失敗）
      2. LateUpdate()で毎フレーム強制更新 → パフォーマンス懸念（却下）
      3. AutoFit無効化 + Screen.Resize()使用 → MediaPipe初期化後に上書き（部分成功）
      4. MediaPipe初期化完了待機（2秒後に再Resize） → **成功**
    - **最終実装**:
      - AutoFit無効化: `autoFitComponent.enabled = false`
      - Screen.Resize()使用: MediaPipe標準メソッドで320x240に変更
      - Coroutineで2秒待機後に再度Resize実行
      - RectTransform配置: anchor(1,0), pivot(1,0), position(-10,10)で右下固定
    - **最終サイズ**: 320x240（右下配置）
  - **ログ最適化**: ArmSwingDetectorの頻繁なログ（Walking detected/stopped）をコメントアウト
  - **動作確認完了**: 腕振り検知でPlayerが前進、MediaPipe画面が右下小窓に正常表示
  - **Git統合完了**:
    - GitHubリポジトリ作成: `https://github.com/nakagimadevelop002-glitch/ShibuyaRiverProject.git`
    - `.gitignore`作成（Unity標準テンプレート）
    - 100MB超シーンファイル除外（MurkyRiverTestScene.unity, TestRiverScene.unity）
    - 初回コミット作成・プッシュ完了
    - Unity.mdに全自動Gitワークフロー追記
- **2025年11月5日**:
  - **Waypoint演出システム実装完了**（カメラ注視演出）
    - **CameraViewController.cs作成**（責任: カメラ注視演出の実行）
      - LookAt(Transform, float) - 指定地点を指定秒数注視
      - onViewCompleted - 演出完了通知UnityEvent
      - コルーチンによる滑らか補間実装
    - **RouteFollower.cs拡張**（最小限の変更でSOLID原則遵守）
      - WaypointEvent構造体拡張（Waypoint番号指定方式）
        - waypointIndex - イベントを発火するWaypoint番号
        - lookAtTarget - 注視対象Transform（設定時に自動実行）
        - lookDuration - 注視継続時間（秒）
        - onReached - 追加演出UnityEvent（パーティクル、音等）
      - **UnityEvent設定不要化**: lookAtTarget設定だけで自動実行
      - 必要な演出のみを定義、空要素なし → **Null参照リスク完全排除**
      - LookAtWithPause() - カプセル化private メソッド
        - 移動停止→注視→自動再開を1つのメソッドに集約
        - WaypointEventから自動呼び出し
      - CameraViewControllerの自動検索・自動初期化
      - onViewCompletedへのResumeMovement自動登録
      - Tell, Don't Ask原則: RouteFollowerは演出の詳細を知らない
    - **設計哲学**:
      - Single Responsibility: RouteFollowerは移動管理、CameraViewControllerは演出実行
      - Open/Closed: 追加演出はonReachedで拡張可能、コード変更不要
      - Dependency Inversion: 抽象（UnityEvent）に依存、具体的な演出を知らない
      - **カプセル化**: 複雑な処理を隠蔽、設定を最大限簡略化
      - **Fail-Safe設計**: Waypoint番号検索方式、Null安全性確保
    - **使用方法**: RouteFollowerのInspectorで全て設定可能（最終簡略版）
      ```
      Waypoint Events → Element 0:
      ├─ Waypoint Index: 2
      ├─ Look At Target: [遺跡をドラッグ]
      └─ Look Duration: 3
      ```
      **UnityEvent設定不要。以上で完了。**
    - **コード品質**:
      - 全メソッドにサマリー（役割説明）記述
      - 全処理に意図コメント記述（Unity.md規約遵守）
      - 不要なpublicメソッドをprivate化
    - **コード肥大化なし**: RouteFollower +40行、CameraViewController 新規120行
  - **警告修正 & カプセル化強化**:
    - **ImageSource.cs修正**（MediaPipeUnityPlugin）
      - `Resolution.refreshRate`（obsolete）→ `refreshRateRatio.value`に変更
      - Unity 2022.3対応
    - **FadingMovementSMB.cs修正**
      - 未使用フィールド`isCompleted`削除（CS0414警告解消）
    - **CameraViewController.cs カプセル化強化**
      - `public UnityEvent onViewCompleted` → `private System.Action onCompleted`に変更
      - LookAt()の第3引数でコールバック受け取り方式に変更
      - **Inspector不要化**: UnityEventフィールドが完全に非表示に
    - **RouteFollower.cs簡略化**
      - AddListener/RemoveListener削除（UnityEvent購読不要に）
      - `LookAt(target, duration, ResumeMovement)`でコールバック直接渡し
      - OnDestroy()のイベント購読解除処理削除
    - **設計哲学の貫徹**:
      - Tell, Don't Ask: コールバックは命令時に渡す
      - 完全カプセル化: 外部から内部実装にアクセス不可
      - Inspector簡略化: ユーザーが設定する項目を最小限に
  - **カメラ統合システム実装完了**（YOLO + MediaPipe 共存実現）:
    - **SharedCameraImageSource.cs作成**
      - CameraInput → MediaPipe ブリッジ
      - ImageSource インターフェース実装
      - Texture2D 共有でカメラ競合解決
    - **MediaPipeCameraIntegration.cs作成**
      - Bootstrap 動的生成待機（最大10秒）
      - ImageSourceProvider.ImageSource 上書き（リフレクション）
      - IsReady フラグで PoseLandmarkerRunner と同期
      - DefaultExecutionOrder(100) で実行順序制御
    - **PoseLandmarkerRunner.cs修正**
      - DefaultExecutionOrder(200) 追加
      - MediaPipeCameraIntegration.IsReady 待機
      - WebCamSource 競合完全回避
    - **動作確認完了**:
      - ✅ カメラ1つのみ起動（競合なし）
      - ✅ YOLO 人数検知動作（水面変化）
      - ✅ MediaPipe 腕振り検知動作（前進）
      - ✅ カメラ統合ログ正常出力
  - **RouteFollower 3次元移動対応**:
    - Y軸固定を削除（`targetPosition.y = transform.position.y;` 削除）
    - Waypoint の高さ（Y座標）にも移動可能に
    - 階段、坂、ジャンプ台などの高低差対応
    - カメラ回転は水平方向のみ維持（VR酔い防止）
